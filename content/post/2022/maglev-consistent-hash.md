---
title: "Maglev Consistent Hasher and Load Balancer"
date: 2022-03-31T18:33:57+08:00
lastmod: 2022-05-21T06:15:00+08:00
draft: false
tags: ["maglev", "一致性哈希"]
categories: ["技术"]
---
>本文重点描述Maglev一致性哈希算法，并原创性提出让Maglev一致性哈希算法支持带权重候选节点的做法，
>以及描述了一致性哈希下的动态负载均衡策略，并给出开源实现代码。


## 一致性哈希
一致性哈希是一种将属于无限集的key稳定的映射到属于有限集的候选节点上的算法，它需要满足：
* 稳定：候选节点集合不变时，一个固定的key，会稳定不变地映射到某一个候选节点上；
* 最小扰动：当增加或减少候选节点时，只有少部分key需要重新映射，大部分key的映射结果不变；
* 均衡：不同key应该均匀地分散到各个候选节点上，即一个key映射到每一个候选节点上的概率是一样的。

## 常见一致性哈希算法
环形哈希，也叫割环法，经典的一致性哈希算法，作者Karger等人于1997年提出一致性哈希算法的概念，
然后提出了这个一致性哈希算法。
更新和查询时间复杂度都是O(log(n))，空间复杂度O(n)，
但是通常均衡性不好，需要加入较多虚拟节点，也就加倍了时间和空间复杂度。


Jump Consistent Hash。极简的一致性哈希算法，不到十行代码。
查询时间复杂度是O(log(n))，不需要更新操作，也不需要额外存储空间。
但是不能随机增删候选节点，只能在有序候选节点队列的尾部增删节点，实用性不强。


Maglev一致性哈希算法。
查询时间复杂度O(1)，更新时间复杂度O(m)，空间复杂度O(m)，m通常为至少比n大10倍以上的一个素数常量。
下面重点介绍。

## Maglev一致性哈希算法描述

1. 选取哈希槽长度，素数M，生成空哈希槽数组；
2. 将候选节点列表排序；
3. 对每一个候选节点哈希得到两个随机数A、B(模M-1再加1保证非0或M的倍数)，然后得到一个从0到M-1的排列：X[k] = (A + k*B)%M, k=0,1,...,M-1；
4. 排列中每一个数字代表一个槽位，轮询每一个候选节点的排列，从左到右选择排列中的第一个空槽位填充进去，直到哈希槽填充完整为止；
5. 对一个输入key，通过 key%M 映射到哈希槽中对应的候选节点。（这里的key通常需要哈希一下得到一个大随机数）

优缺点：
* 优点：分片均匀，查询速度快O(1)
* 缺点：更新较慢O(n)


## 一致性哈希支持带权重候选节点

### 通用做法：增加虚拟节点
通常一致性哈希算法都是不支持带权重候选节点的，也就是一个key映射到每一个候选节点的概率是相等的。
因此，想要实现带权重的一致性哈希的一个普遍思路是增加虚拟节点。将一个实际的候选节点拆成多个虚拟节点，
拆成的虚拟节点的多少，即代表了这个实际候选节点的权重的大小。

### Maglev一致性哈希算法支持带权重候选节点的特殊做法：按权重正比概率阈值填充哈希槽位。
通常，增加虚拟节点的做法相当于增加了候选节点数n，如果时间空间复杂度与n有关，那么会相应增加复杂度。
其次，如果虚拟节点数增加的少，那么实际的权重比例会比较粗糙，即精度不够。

Maglev算法的查询时间复杂度与n无关，是O(1)，所以增加虚拟节点法不会影响Maglev的查询速度，
但是由于Maglev算法需要选取一个比候选节点数大很多的大素数M，且这个M关系到更新的时间复杂度和占用的空间复杂度，
因此采用增加虚拟节点法也会增加一些消耗。

观察Maglev算法哈希槽的填充过程可知，该算法是轮训每一个候选节点，让每一个候选节点占有一个哈希槽后才轮到下一个候选节点。
因此可以试想，只要让轮训到当前候选节点时，不一定完全占有一个候选节点，而是设定一个与该节点的权重成正比的概率阈值，
达到这个阈值后才占有一个哈希槽。这个概率阈值可以是：当前节点的权重除以所有节点的权重的最大值。
可以看出，无权重的情况，也就相当于每一个候选节点的权重都相等，因此对应的概率阈值也都相等，都是1。
另外，为了保证一致性哈希算法的稳定性，这里的概率生成要用稳定的伪随机概率，每一个候选节点用自己的固定信息，
比如节点ID，作为一个伪随机序列的种子，用这个伪随机序列称重的概率与对应的概率阈值相比较，来判断该节点在这一次轮训中要不要占有一个哈希槽位。


## 一致性哈希下的动态负载均衡
由开头对一致性哈希算法的描述中可以，输入的key是属于无限集的，是无法提前预知的，无法对其做任何分布性的要求。
因此，极有可能，输入的key就是极其不均衡的，而纯粹的一致性哈希又是要求结果必须是稳定的，所以不均衡的输入集，
最终会造成不均衡的映射结果。比如常见的热key问题，纯一致性哈希是无法解决的。

因此，为了在未知的不确定的任意的输入集上都保持良好的均衡性，需要动态的调整映射策略，需要统计感知每一个候选节点当前的负载情况，
如果负载过高，则应该将当前key用某种算法重新映射到另外一个节点上，而这个重新映射的算法最好也是稳定的。

对于Maglev算法来说，一个简单的重新映射算法可以是：`(key + (key % C + 1) * retry_cnt) % M`。
其中C是某一个常数，而retry_cnt是重新映射次数。


## 开源实现
以上所描述的Maglev一致性哈希算法，以及在此一致性哈希基础上的动态负载均衡策略，笔者已有一个完整的C++开源实现。
代码详见我的GitHub：[cpp-maglev](https://github.com/peacalm/cpp-maglev)
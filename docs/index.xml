<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Peacalm Notes - 双全的网站</title>
    <link>https://peacalm.github.io/</link>
    <description>Recent content on Peacalm Notes - 双全的网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 18 Apr 2022 19:04:20 +0800</lastBuildDate>
    
        <atom:link href="https://peacalm.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>在线服务的异步RPC延时控制和无锁异步任务同步组件</title>
      <link>https://peacalm.github.io/post/lockless-sync-kit/</link>
      <pubDate>Mon, 18 Apr 2022 19:04:20 +0800</pubDate>
      
      <guid>https://peacalm.github.io/post/lockless-sync-kit/</guid>
      
        <description>&lt;h2 id=&#34;一关于延时&#34;&gt;一、关于延时&lt;/h2&gt;
&lt;h3 id=&#34;控制延时是保证在线服务可用性的必要手段&#34;&gt;控制延时是保证在线服务可用性的必要手段&lt;/h3&gt;
&lt;p&gt;在线服务对延时敏感。一般对在线服务发起远程调用时，都会配有一个超时限制，一旦请求超时，
则认为本次请求失败，服务不可用。因此控制延时是保证在线服务可用性的必要手段。&lt;/p&gt;
&lt;h3 id=&#34;rpc远程调用耗时的复杂性&#34;&gt;RPC远程调用耗时的复杂性&lt;/h3&gt;
&lt;p&gt;网络环境是不可靠的，数据在网络中传输的耗时是不可控的，因此为了控制延时，
需要为每次socket发送和接受数据都配置一个超时限制。
而一次RPC远程调用可能需要执行多次socket请求，例如数据包很大、io状态不佳、需要重试等原因，
因此为单次socket请求设置的超时限制，并不能准确代表一次RPC远程调用的网络耗时。&lt;/p&gt;
&lt;p&gt;因此，为了更准确控制超时，一些RPC框架内置了io线程池，采用异步方式进行socket网络请求，
超时控制会比同步模式准确一些。&lt;/p&gt;
&lt;p&gt;不过，虽然异步请求是比同步请求模式更先进的控制超时的方式，但更复杂，
也引入了更多影响延时的因素和需要关注和调优的参数。
例如，异步模式虽然可以避免多次socket请求对超时控制的影响，但又引入了
io线程池的调度耗时、控制异步io超时的定时器的准确性等因素对总体RPC延时的影响。&lt;/p&gt;
&lt;p&gt;再退一步，从业务客户端视角看，一次RPC远程调用的耗时，除了网络耗时，
还包括数据在本端（客户端）和远端（服务端）的序列化和反序列化耗时，当数据包过大时，
这一部分耗时和对CPU的消耗也是不能忽视的。&lt;/p&gt;
&lt;h3 id=&#34;异步rpc是必要的&#34;&gt;异步RPC是必要的&lt;/h3&gt;
&lt;p&gt;因此，使用异步RPC远程调用总是必要的，除了能使延时控制得更准确外，还可以并行执行多个RPC请求，
进一步降低延时，而并行执行一些相互独立的任务也是降低延时的非常重要的优化策略。&lt;/p&gt;
&lt;p&gt;更进一步，除了RPC框架内置的异步网络请求模式外，还可以再退一层，站在业务的更大的视角上看，
在在线服务内建立线程池，用于执行异步任务，这些异步任务不仅可以包括RPC框架涵盖的网络请求，
还可以包含数据的序列化反序列化，以及业务上需要特殊处理的逻辑。
例如，假如一个业务上的异步任务其实内部需要先后访问两次远程服务，然后再做一些处理，
那么用一个业务上的异步任务给它一个整体上的超时，对业务上讲，控制延时将更准确。
或者，业务上的异步任务可以仅仅是对使用了同步RPC框架的一次RPC任务的封装，那么这个业务上设定的超时，
就包含了网络耗时、数据序列化反序列化耗时、业务特殊处理逻辑等所有步骤的耗时，
比单独使用RPC框架的超时，控制延时更准确。&lt;/p&gt;
&lt;h2 id=&#34;二关于同步&#34;&gt;二、关于同步&lt;/h2&gt;
&lt;p&gt;异步执行的程序之间总是需要同步的。&lt;/p&gt;
&lt;h3 id=&#34;无锁同步&#34;&gt;无锁同步&lt;/h3&gt;
&lt;p&gt;线程间同步一般常用锁，例如互斥锁、读写锁等，而&amp;quot;无锁&amp;quot;同步，一般就要直接使用原子标记，事实上，
锁的内部实现方式也是使用了原子标记。&lt;/p&gt;
&lt;h3 id=&#34;异步任务同步&#34;&gt;异步任务同步&lt;/h3&gt;
&lt;p&gt;业务上给每一个异步任务都设定一个预期的超时时间，主线程发送出一个或多个异步任务后，
等待一段时间——这个时间应该是这些异步任务超时时间的最大值——让这些任务并行执行一会儿，
然后需要判断异步任务执行得怎么样了，是已经成功了？或是已经失败了？或是还在执行中？
如果还在执行中，那么主线程可以给这个任务标记为&amp;quot;已超时&amp;quot;，
让这个超时任务不要再影响主线程，或进入超时任务的特殊处理方法。&lt;/p&gt;
&lt;p&gt;异步任务成功或失败的标记信息，是任务线程发送给主线程的信号，
而任务已超时的信息，是主线程发送给任务线程的信号。
这些就涉及到线程间同步问题。&lt;/p&gt;
&lt;h3 id=&#34;异步任务无锁同步组件c为例&#34;&gt;异步任务无锁同步组件，C++为例&lt;/h3&gt;
&lt;p&gt;以下C++实现代码中 SyncKit类 就是一个简单的异步任务无锁同步组件，
它是主线程和异步任务线程共享的数据结构，分别为其定义了可调用成员方法。
主线程调用master_开头的方法，异步任务线程调用slave_开头的方法。&lt;/p&gt;
&lt;p&gt;主线程使用方式很简单，发出异步任务后等待一段时间，然后调用master_check_ret()检查结果即可。
任务线程使用方式稍微复杂，主要要保证任务完成后将结果数据写入主线程提供的承载任务结果的数据结构时，
要保证主线程尚在等待，还没有标记超时。否则，如果主线程已经标记了超时，代表主线程可能已经开始使用
承载任务结果的数据结构了，如果此时任务线程还对这个数据结构进行修改，那么就会造成并发安全问题。
slave样例伪代码见下代码注释中。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// 用于保存异步任务执行结果的整型状态码。
// 正数为任务成功，负数为任务失败，0代表尚未完成，可被判成超时。
class TaskResultCode {
public:
  TaskResultCode() : ival_(0) {}

  int value() const { return ival_; }

  bool unready() const { return ival_ == 0; }
  bool succeeded() const { return ival_ &amp;gt; 0; }
  bool failed() const { return ival_ &amp;lt; 0; }

  template &amp;lt;int i = 1&amp;gt;
  void set_succeeded() {
    static_assert(i &amp;gt; 0, &amp;quot;success code should be positive&amp;quot;);
    ival_ = i;
  }

  template &amp;lt;int i = -1&amp;gt;
  void set_failed() {
    static_assert(i &amp;lt; 0, &amp;quot;failure code should be negative&amp;quot;);
    ival_ = i;
  }

private:
  std::atomic&amp;lt;int&amp;gt; ival_;
};


// 异步任务同步工具。主线程为master，任务线程为slave。
// 主线程发送异步任务时，打包一个SyncKit用作同步，同时还可以传入一个共享数据结构，
// 用于让slave把任务执行结果数据保存在此。
class SyncKit {
public:
  SyncKit() = default;

  // 主线程master检查异步任务执行结果，如果尚未完成则标记已经超时。
  const TaskResultCode&amp;amp; master_check_ret() {
    if (task_done_) {
      return ret_;
    }
    is_timeout_ = true;
    if (slave_checking_timeout_) {
      while (!task_done_) {}  // waiting
      return ret_;
    }
    return ret_;
  }

  // 主线程检master查任务结果，但不标记超时。
  const TaskResultCode&amp;amp; master_peek_ret() { return ret_; }

  /**
   * slave code example:
   *
   * if slave_test_timeout():
   *   return
   * if invalid parameters or conditions:
   *   slave_set_failed_unsafe&amp;lt;some failure code&amp;gt;
   *
   * slave starts to run a task。 e.g. do some RPC.
   * 
   * // 异步任务已经完成，准备将任务结果写回到与master共享的数据结构中。
   * // 写之前先判断master是否已经标记超时。
   * if slave_check_whether_timeout():
   *     return
   * 
   * // 尚未超时，master还在等待。此后的代码逻辑必须保证slave一定会调用
   * // slave_set_failed&amp;lt;failure code&amp;gt;()或slave_set_succeeded&amp;lt;success code&amp;gt;()
   * // 并最终对 task_done_ 赋值为true，否则可能阻塞主线程。
   * 
   * if task failed:
   *     slave writes failed result to shared data or does nothing.
   *     slave_set_failed&amp;lt;some failure code&amp;gt;()
   * else:
   *     slave writes succeeded result to shared data.
   *     slave_set_succeeded&amp;lt;some success code&amp;gt;()
   *
   */

  // 任务线程slave检查主线程master是否已经标记超时。如果已经标记为超时，
  // 则slave不能再对与master共享的数据结构做任何修改，因为此时master可能正在读取这些数据。
  // 任务线程slave在修改与master共享的数据结构之前，必须调用此方法确保尚未超时。
  bool slave_check_whether_timeout() {
    slave_checking_timeout_ = true;
    if (is_timeout_) {
      task_done_ = true;
      return true;
    } else {
      return false;
    }
  }

  bool slave_test_timeout() const { return is_timeout_; }

  template &amp;lt;int failure_code = -1&amp;gt;
  void slave_set_failed() {
    ret_.set_failed&amp;lt;failure_code&amp;gt;();
    task_done_ = true;
  }

  template &amp;lt;int success_code = 1&amp;gt;
  void slave_set_succeeded() {
    ret_.set_succeeded&amp;lt;success_code&amp;gt;();
    task_done_ = true;
  }

  // use default code 1 for succeeded and -1 for failed.
  void slave_set_ret(bool succeeded) {
    if (succeeded) {
      slave_set_succeeded();
    } else {
      slave_set_failed();
    }
  }

  // unsafe, could call this without calling slave_check_whether_timeout first.
  // 但是可能导致master观测到的TaskResultCode变化一次，从0变为负数。
  template &amp;lt;int failure_code = -1&amp;gt;
  void slave_set_failed_unsafe() {
    if (!is_timeout_) {
      ret_.set_failed&amp;lt;failure_code&amp;gt;();
    }
    task_done_ = true;
  }

private:
  std::atomic&amp;lt;bool&amp;gt; is_timeout_{false};
  std::atomic&amp;lt;bool&amp;gt; slave_checking_timeout_{false};
  std::atomic&amp;lt;bool&amp;gt; task_done_{false};
  TaskResultCode ret_;
};



// 以下是一些配套工具代码

typedef std::shared_ptr&amp;lt;SyncKit&amp;gt; SyncKitPtr;

inline SyncKitPtr new_sk() { return std::make_shared&amp;lt;SyncKit&amp;gt;(); }

struct SyncKitGuard {
  SyncKitPtr sk;
  std::string name;

  SyncKitGuard() : sk(new_sk()) {}

  SyncKitGuard(std::string n) : sk(new_sk()), name(std::move(n)) {}

  SyncKitGuard(std::string n, SyncKitPtr orther_sk) : sk(orther_sk), name(
      std::move(n)) { assert(sk != nullptr); }

  SyncKitGuard(SyncKitGuard&amp;amp;&amp;amp; r) : sk(std::move(r.sk)),
                                   name(std::move(r.name)) { r.sk = nullptr; }

  SyncKitGuard(const SyncKitGuard&amp;amp; r) = delete;

  ~SyncKitGuard() {
    if (sk) sk-&amp;gt;master_check_ret();
  }
};

struct SyncKitGuardList : public std::list&amp;lt;SyncKitGuard&amp;gt; {
  SyncKitGuard&amp;amp; new_back(std::string name = &amp;quot;&amp;quot;) {
    push_back(SyncKitGuard(std::move(name)));
    return back();
  }
};

struct SyncKitGuardMap : public std::map&amp;lt;std::string, SyncKitGuard&amp;gt; {};

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;留一个思考题，SyncKit类中的这些原子bool类型，最低需要使用什么MemoryOrder呢？
sec_cst? release-acquire? relaxed?&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>What Is a Good Local Cache</title>
      <link>https://peacalm.github.io/post/what-is-a-good-local-cache/</link>
      <pubDate>Thu, 31 Mar 2022 02:15:21 +0800</pubDate>
      
      <guid>https://peacalm.github.io/post/what-is-a-good-local-cache/</guid>
      
        <description>&lt;p&gt;缓存技术，Cache，特别是LocalCache，是软件开发中非常常用的组件，也是提高性能的最简单的方式。
Cache一般有SideCar和Wrapper两种使用模式。&lt;/p&gt;
&lt;h2 id=&#34;cache的使用模式&#34;&gt;Cache的使用模式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;SideCar模式：需要应用程序自己主动访问数据源服务并读写缓存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种模式可以是LocalCache，与应用程序集成部署，但是由于Cache功能与业务逻辑无耦合，非常独立，所以出现了很多优秀的独立出来的非常通用的第三方独立缓存服务，
比如Redis，Memcached等。
独立缓存服务一般与应用程序分开，独立部署，需要通过网络进行交互，数据量较大或对性能要求较高时，网络带宽消耗、延时、数据序列化反序列化的CPU消耗不能忽视。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;Cache
↑  
|  
App  --&amp;gt;   DataSource
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Wrapper模式：应用程序只需要访问缓存，缓存具有代理能力可以帮助应用程序去访问数据源服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种模式需要对Cache做特殊化定制，一般是LocalCache，与应用程序集成部署，只需在内存中进行交互，性能较高。如果Cache设计的好，可以极大简化业务代码，
可以提高组件可复用性。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;App --&amp;gt; Cache --&amp;gt; DataSource
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那么怎么才算是一个好的LocalCache呢？从业务应用上要灵活好用，满足多种多样的业务需求，同时也要具有基本的高性能。&lt;/p&gt;
&lt;h2 id=&#34;灵活好用&#34;&gt;灵活好用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;具有单Key读写接口，也具有Batch读写接口。&lt;/li&gt;
&lt;li&gt;可以动态修改CacheSize，一般指缓存的数据条目数。&lt;/li&gt;
&lt;li&gt;可配置缓存策略，例如：LRU，LRU-k(lazy list adjustment)，FIFO等。&lt;/li&gt;
&lt;li&gt;可以设置一个数据的默认过期时间，也可以动态设置每一个Key的过期时间，特别的，在插入或读取时都可以设置和判断过期。&lt;/li&gt;
&lt;li&gt;可以配置读取数据源服务的CallbackOnFetching方法，以便应用Wrapper模式，当Key不存在或过期时，用来获取新数据。&lt;/li&gt;
&lt;li&gt;过期数据不自动删除，可配置一个CallbackOnExpiration方法来注入对过期数据的处理方式。比如可以删除数据，或把过期数据发送到某个消息队列、写入硬盘等，
或不对过期数据做任何处理，只等缓存用满以后自动逐出。&lt;/li&gt;
&lt;li&gt;支持多种QueryFlags:
&lt;ul&gt;
&lt;li&gt;Uncacheable:   本次Query不读写Cache，只从数据源服务获取数据并返回，不写入Cache，相当于没有Cache，只对Query做转发。&lt;/li&gt;
&lt;li&gt;Refresh:       本次Query不读取Cache数据，重新从数据源服务获取最新数据，并写入Cache，相当于刷新缓存。&lt;/li&gt;
&lt;li&gt;Peek:          本次Query只读取Cache数据，即使Miss或Expired也不从数据源服务获取最新数据，可用于窥测Cache状态，或保护后端数据源服务。&lt;/li&gt;
&lt;li&gt;Stale:         本次Query读取Cache数据时，可以接受过期的数据。&lt;/li&gt;
&lt;li&gt;StaleFailover: 本次Query如果从远程数据源服务读取数据失败，则可以接受Cache中的过期的数据。&lt;/li&gt;
&lt;li&gt;Fast:          本次Query只返回Cache里的数据，如果Miss或Expired，则发送eload任务刷新缓存，不阻塞当前Query。&lt;/li&gt;
&lt;li&gt;Preload:       本次Query如果在Cache中读取到合法数据，但是数据快过期了（比如已过了过期时间的80%，阈值可配置），则发送一个Reload任务来刷新缓存。&lt;/li&gt;
&lt;li&gt;ReturnExpired: 本次Query如果在Cache中读到了过期的数据，则把过期的数据也一起返回，供用户自主决定处理方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内置线程池可执行Reload任务，从数据源服务获取数据并填充Cache。&lt;/li&gt;
&lt;li&gt;可配置内置WatchDog线程，检查快要过期的数据并发送Reload任务，或清理过期数据等。&lt;/li&gt;
&lt;li&gt;可迭代操作Cache中的每一条数据，例如把Cache中的数据读出写入到其他设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;高性能&#34;&gt;高性能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;并发性好。例如采用分桶机制、采用TBB的高性能并发容器库等。&lt;/li&gt;
&lt;li&gt;内存使用效率高。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Parameters Management for Online Service</title>
      <link>https://peacalm.github.io/post/parameters-management-for-online-service/</link>
      <pubDate>Thu, 17 Mar 2022 22:01:30 +0800</pubDate>
      
      <guid>https://peacalm.github.io/post/parameters-management-for-online-service/</guid>
      
        <description>&lt;p&gt;互联网公司业务发展快，策略复杂，软件迭代变更非常频繁。因此有必要有一套良好的参数管理思想控制在线服务的表现，以支持业务的频繁变更和AB实验等。&lt;/p&gt;
&lt;h2 id=&#34;参数分类&#34;&gt;参数分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认配置参数：分为远程配置和本地配置。远程配置可动态修改、动态加载，而不需要升级或重启服务，使用方便，
但是有稳定性和可靠性风险，比如由于网络中断、提供远程配置的载体服务异常等原因而导致取不到配置信息。
因此，还需要一套本地配置，随服务一起发布，理论上配置信息应该与远程配置是一模一样的，
但由于本地配置发布频率低，可能会比远程配置版本低，不过问题不大，本地配置主要是对远程配置不可用时做兜底的，
生效时机较少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实验参数：一般指AB实验的策略配置参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降级参数：服务故障时，临时注入的策略参数，用于降低策略复杂度、降低服务消耗、提高服务可用性，可能会对实验指标、效果指标有损。
由于AB实验指标可能对业务发展比较重要，因此降级参数还可以再细分一下优先级，分为优先级高于AB实验参数的高优降级参数和优先级低于AB实验参数的低优降级参数。
发生轻微故障时，使用低优降级参数则不会对实验指标有影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优先级&#34;&gt;优先级&lt;/h2&gt;
&lt;p&gt;服务初始化时，按照一定优先级合并多种参数用于后续处理。综上描述，按优先级从高到低，这一套在线服务参数的排列顺序是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;高优降级参数 -&amp;gt; 实验参数 -&amp;gt; 低优降级参数 -&amp;gt; 默认配置参数(远程配置参数 或 本地配置参数)
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>C&#43;&#43;轻量级输出库MyOStream：可打印输出所有成员可迭代的容器</title>
      <link>https://peacalm.github.io/post/myostream/</link>
      <pubDate>Thu, 17 Mar 2022 01:12:25 +0800</pubDate>
      
      <guid>https://peacalm.github.io/post/myostream/</guid>
      
        <description>&lt;h2 id=&#34;懒汉的烦恼&#34;&gt;懒汉的烦恼&lt;/h2&gt;
&lt;p&gt;使用C++编程时对数据打印输出比较麻烦，需要自行用for循环将vector, list, map等容器的成员一一打印输出。
相比之下Python, Golang等语言就可以直接对所有数据类型打印输出，这对于debug是很友好的特性。
因此，我开发了一个简单的C++库，几乎能够对所有容器直接打印输出，说几乎是因为我们只能对成员可访问可迭代的容器支持这个特性。&lt;/p&gt;
&lt;p&gt;支持的类型如下，以及他们的组合类型：&lt;/p&gt;
&lt;p&gt;std::pair, std::tuple, std::array, std::deque,
std::forward_list, std::initializer_list, std::list, std::vector,
std::set, std::multiset, std::unordered_set, std::unordered_multiset,
std::map, std::multimap, std::unordered_map, std::unordered_multimap.&lt;/p&gt;
&lt;h2 id=&#34;acmer助手&#34;&gt;ACMer助手&lt;/h2&gt;
&lt;p&gt;特别的，我们在打ACM比赛或做类似的OJ题目的过程中，需要debug的时候，我们不仅想要打印容器里的值，
而且还想要同时打印出变量名，以便我们在解题时，如果定义了多个容器变量，我们可以知道哪个变量的值使哪一个值，
因此我设计了watch功能。&lt;/p&gt;
&lt;p&gt;例如，如下debug代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#ifndef ONLINE_JUDGE
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;myostream.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;myostream&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ostream mycout(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout.rdbuf());
&lt;span style=&#34;color:#75715e&#34;&gt;#define watch(...) MYOSTREAM_WATCH(mycout, &amp;#34; = &amp;#34;, &amp;#34;\n&amp;#34;, &amp;#34;\n\n&amp;#34;, __VA_ARGS__)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#else
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define watch(...)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#endif
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; v{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;};
  watch(v);

  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;tuple&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;set&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;,
      std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;pair&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; complex({&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;},
                                              {{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;aa&amp;#34;&lt;/span&gt;}},
                                               {&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;bb&amp;#34;&lt;/span&gt;}}},
                                              {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Aya&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;88.5&lt;/span&gt;});
  watch(complex);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在本地编译运行，可以输出：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;v = [1, 2, 3]

complex = &amp;lt;[1, 2, 3], {1: {a, aa}, 2: {b, bb}}, (Aya, 88.5)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而在线提交，或定义了宏ONLINE_JUDGE后，则什么都不输出。&lt;/p&gt;
&lt;h2 id=&#34;附录&#34;&gt;附录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/peacalm/myostream&#34;&gt;lib MyOStream on github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>字节跳动发展史</title>
      <link>https://peacalm.github.io/post/bytedance-growth/</link>
      <pubDate>Fri, 04 Mar 2022 02:50:04 +0800</pubDate>
      
      <guid>https://peacalm.github.io/post/bytedance-growth/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2012年3月9日，字节跳动Bytedance成立于北京海淀锦秋家园一个四居室内。&lt;strong&gt;天使轮融资&lt;/strong&gt;，500万元，顺为资本、晨兴资本投资。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2012年5月，内涵段子发布。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2012年7月，&lt;strong&gt;A轮融资&lt;/strong&gt;，500万美元，SIG海纳亚洲独家投资。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2012年8月，今日头条1.0版本上线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2012年10月，累计用户数超过1000万。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2012年底，1500万激活用户数，近160万DAU。今日头条DAU超过100万？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年5月下旬，&lt;strong&gt;B轮融资&lt;/strong&gt;，5000万美元，俄罗斯投资集团DST独家投资。公司估值千万+美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年5月，第一次搬家，搬入盈都大厦10层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年8月，今日头条用户数突破5000万。开始尝试商业化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年11月，今日头条和内涵段子激活用户数超过6000万，DAU接近600万，公司人数接近一百人。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013年12月，累计用户数超过9500万。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2014年4月，今日头条MAU3000万。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2014年6月，今日头条激活用户数1.2亿，MAU4000万。&lt;strong&gt;C轮融资&lt;/strong&gt;，1亿美元，红杉资本、新浪微博基金领投。公司估值5亿美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2014年12月，累计激活用户超过2亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2014年底，公司人数约500人？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015年1月，今日头条累计用户2.2亿，DAU2000万。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015年4月，累计激活用户超过2.5亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015年7月，总DAU超过5000万（WAP端+移动端），累计激活用户超过2.7亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015年9月，累计激活用户数超过3亿，DAU超过3000万。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015年9月8日，今日头条推出头条号“千人万元”计划，同时推出“新媒体孵化器计划”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2015年底，今日头条DAU3300万，公司人数大约1200人。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年2月，今日头条开辟“头条寻人”平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年2月28日，从盈都搬到了中航广场。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年6月，累计激活用户数超过5亿，DAU超过4800万。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年8月，今日头条战略投资国内知名图片库东方IC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年8月底，累计激活用户数超过5.5亿，DAU超过6000万。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年9月，抖音上线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年9月20日，张一鸣宣布将在未来一年拿出10亿人民币扶持短视频创作者。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年10月15日，今日头条领投印度版今日头条Dailyhunt D轮融资。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年10月，今日头条激活用户数超过6亿，MAU超过1.4亿，DAU超过6600万，单用户日均使用时长超过76分钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年12月，&lt;strong&gt;D轮融资&lt;/strong&gt;，10亿美元，建银国际、红杉资本投资。公司估值110亿美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年底，今日头条累计激活用户数超过7亿，DAU超过7800万。公司人数4千？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016年营收约60亿元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年2月，5000万美元全资收购美国移动短视频创作者社区Flipagram。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年5月，TikTok上线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年9月，&lt;strong&gt;E轮融资&lt;/strong&gt;，2亿美元，老虎基金、美国泛大西洋(600558)投资集团投资。公司估值220亿美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年11月，5000万美元投资猎豹移动旗下Live.me，8660万美元收购猎豹移动旗下News Republic，10亿美元收购Musical.ly，系彼时最大收购。
Musical.ly MAU6000万，美国MAU2000万，49%的用户都在美国。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年11月，公司内部开始全面使用飞书（当时名为Lark）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年底，公司人数1.3万？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017年营收约160亿元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年1月，TikTok MAU5500万。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年2月，3亿美元收购Faceu激萌。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年4月，抖音DAU破亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年4月10日下午，内涵段子被关停。损失2000万DAU，50亿年收入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年4月，公司品牌名从&amp;quot;今日头条&amp;quot;改为&amp;quot;字节跳动&amp;quot;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年10月，&lt;strong&gt;Pre-IPO轮投资&lt;/strong&gt;，40亿美元，春华资本、软银中国、云锋基金投资。公司估值750亿美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年12月，TikTok MAU 2.7亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年底，公司人数3.5万？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2018年营收约500亿元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2019年1月，3亿人民币收购锤子科技部分专利使用权，探索教育领域相关业务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2019年7月，成立教育部门ZERO，陈林为负责人。朱文佳接替陈林作为今日头条CEO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2019年12月，TikTok MAU 5亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2019年底，公司人数6万？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2019年营收约1400亿元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年1月，抖音宣布DAU超过4亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年3月30日，&lt;strong&gt;战略融资&lt;/strong&gt;，Tiger Global Management(老虎环球基金)投资，未披露金额。公司估值达1000亿美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年6月，员工数7万？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年7月，TikTok MAU 6.9亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年9月，抖音宣布DAU突破6亿（抖音火山合并）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年10月，&lt;strong&gt;战略融资&lt;/strong&gt;，20亿美元，红杉资本、KKR等投资。公司估值1800亿美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年10月底，教育部门ZERO启用全新品牌&amp;quot;大力教育&amp;quot;，陈林出任CEO，教育部门已超过一万人，决心三年不盈利，专心做产品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年底，全球所有应用程序的月活用户数达19亿。员工数超过十万人，其中正式员工近9万人。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020年营收约2400亿元。营收343亿美元，毛利润增长93%至190亿美元，经营亏损21亿美元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2021年3月，40美元收购沐瞳科技（100亿人民币现金和价值150亿人民币的股权）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2021年5月20日，张一鸣宣布卸任CEO，梁汝波继任，年底完成交接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2021年8月，收购VR创业公司Pico，50亿元？15亿美元(97亿人民币)？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2021年9月，TikTok MAU 10亿，DAU 6亿。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2021年11月，梁汝波宣布组织调整，成立6个业务板块：抖音（包括头条、西瓜、搜索、百科等国内信息和服务业务）、大力教育、飞书、
火山引擎（企业级技术服务云平台）、朝夕光年（游戏业务）、TikTok。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2021年营收580亿美元，约3700亿人民币，同比增长70%。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>About</title>
      <link>https://peacalm.github.io/about/</link>
      <pubDate>Wed, 02 Mar 2022 20:55:18 +0800</pubDate>
      
      <guid>https://peacalm.github.io/about/</guid>
      
        <description>&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;
&lt;p&gt;我是李双全，可以叫我双全，男生，河北唐山人，90后，天蝎座，一名程序员，现居北京。&lt;/p&gt;
&lt;h3 id=&#34;工作经历&#34;&gt;工作经历&lt;/h3&gt;
&lt;p&gt;2017-今，北京，字节跳动，后端开发工程师。评论排序系统架构和策略，推荐系统架构和策略。&lt;/p&gt;
&lt;h3 id=&#34;教育经历&#34;&gt;教育经历&lt;/h3&gt;
&lt;p&gt;2010-2017，南京，东南大学，自动化学院，获工学学士和工学硕士学位。&lt;/p&gt;
&lt;h3 id=&#34;业余爱好&#34;&gt;业余爱好&lt;/h3&gt;
&lt;p&gt;读书📖，写字✍️，诗歌&lt;a href=&#34;https://muyesq.cn&#34;&gt;📓&lt;/a&gt;，民谣🎧，健身💪，旅行，逛书店，看展，看音乐剧等等。&lt;/p&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;关于本站&lt;/h2&gt;
&lt;p&gt;Peacalm寓意: peaceful &amp;amp; calm&lt;br&gt;
建站工具：Hugo + GitHubPages&lt;br&gt;
主题：Jane&lt;br&gt;
域名：使用GitHub提供的域名&lt;a href=&#34;https://peacalm.github.io&#34;&gt;peacalm.github.io&lt;/a&gt;或我的个人域名&lt;a href=&#34;https://lishuangquan.cn&#34;&gt;lishuangquan.cn&lt;/a&gt;都可以访问本站&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
